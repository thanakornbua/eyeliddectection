<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="opencv-python&gt;=4.9&#10;mediapipe&gt;=0.10&#10;numpy&gt;=1.26&#10;&#10;" />
              <option name="updatedContent" value="opencv-python&gt;=4.9&#10;mediapipe&gt;=0.10&#10;numpy&gt;=1.26" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/__init__.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;Eyelid detection package&quot;&quot;&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/eyelid_metrics.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/eyelid_metrics.py" />
              <option name="originalContent" value="import math&#10;from dataclasses import dataclass&#10;from typing import Iterable, List, Optional, Tuple&#10;&#10;import cv2&#10;import mediapipe as mp&#10;import numpy as np&#10;&#10;&#10;@dataclass&#10;class EyeMeasurement:&#10;    eyelid_distance: float&#10;    eye_aspect_ratio: float&#10;    is_closed: bool&#10;&#10;&#10;class MediapipeEyelidDetector:&#10;    def __init__(&#10;        self,&#10;        detection_confidence: float = 0.6,&#10;        tracking_confidence: float = 0.6,&#10;        eyelid_threshold: float = 0.21,&#10;    ) -&gt; None:&#10;        self.eyelid_threshold = eyelid_threshold&#10;        self.face_mesh = mp.solutions.face_mesh.FaceMesh(&#10;            max_num_faces=1,&#10;            refine_landmarks=True,&#10;            min_detection_confidence=detection_confidence,&#10;            min_tracking_confidence=tracking_confidence,&#10;        )&#10;&#10;    def close(self) -&gt; None:&#10;        self.face_mesh.close()&#10;&#10;    def process_frame(self, frame: np.ndarray) -&gt; Optional[EyeMeasurement]:&#10;        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)&#10;        results = self.face_mesh.process(rgb)&#10;        if not results.multi_face_landmarks:&#10;            return None&#10;&#10;        landmarks = results.multi_face_landmarks[0]&#10;        eye_indices = {&#10;            &quot;left&quot;: [33, 160, 158, 133, 153, 144],&#10;            &quot;right&quot;: [263, 387, 385, 362, 380, 373],&#10;        }&#10;&#10;        def calc_ratio(indices: Iterable[int]) -&gt; Tuple[float, float]:&#10;            pts = np.array(&#10;                [(landmarks.landmark[i].x, landmarks.landmark[i].y) for i in indices],&#10;                dtype=np.float32,&#10;            )&#10;            vertical = np.linalg.norm(pts[1] - pts[5]) + np.linalg.norm(pts[2] - pts[4])&#10;            horizontal = np.linalg.norm(pts[0] - pts[3])&#10;            ratio = vertical / (2.0 * horizontal + 1e-6)&#10;            return vertical, ratio&#10;&#10;        lid_distances, ratios = [], []&#10;        for eye in eye_indices.values():&#10;            vertical, ratio = calc_ratio(eye)&#10;            lid_distances.append(vertical)&#10;            ratios.append(ratio)&#10;&#10;        eyelid_distance = float(np.mean(lid_distances))&#10;        ear = float(np.mean(ratios))&#10;        is_closed = ear &lt; self.eyelid_threshold&#10;        return EyeMeasurement(eyelid_distance=eyelid_distance, eye_aspect_ratio=ear, is_closed=is_closed)&#10;&#10;&#10;" />
              <option name="updatedContent" value="import math&#10;from dataclasses import dataclass&#10;from typing import Iterable, List, Optional, Tuple&#10;&#10;import cv2&#10;import mediapipe as mp&#10;import numpy as np&#10;&#10;&#10;@dataclass&#10;class EyeMeasurement:&#10;    eyelid_distance: float&#10;    eye_aspect_ratio: float&#10;    is_closed: bool&#10;&#10;&#10;def _angle_between(v1: np.ndarray, v2: np.ndarray) -&gt; float:&#10;    v1_u = v1 / (np.linalg.norm(v1) + 1e-6)&#10;    v2_u = v2 / (np.linalg.norm(v2) + 1e-6)&#10;    dot = np.clip(np.dot(v1_u, v2_u), -1.0, 1.0)&#10;    return float(np.degrees(np.arccos(dot)))&#10;&#10;&#10;@dataclass&#10;class FaceMeasurement:&#10;    eye: EyeMeasurement&#10;    pitch_deg: float&#10;    landmarks_px: Optional[np.ndarray]&#10;&#10;&#10;class MediapipeEyelidDetector:&#10;    def __init__(&#10;        self,&#10;        detection_confidence: float = 0.6,&#10;        tracking_confidence: float = 0.6,&#10;        eyelid_threshold: float = 0.21,&#10;    ) -&gt; None:&#10;        self.eyelid_threshold = eyelid_threshold&#10;        self.face_mesh = mp.solutions.face_mesh.FaceMesh(&#10;            max_num_faces=1,&#10;            refine_landmarks=True,&#10;            min_detection_confidence=detection_confidence,&#10;            min_tracking_confidence=tracking_confidence,&#10;        )&#10;&#10;    def close(self) -&gt; None:&#10;        self.face_mesh.close()&#10;&#10;    def process_frame(self, frame: np.ndarray, include_landmarks: bool = False) -&gt; Optional[FaceMeasurement]:&#10;        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)&#10;        results = self.face_mesh.process(rgb)&#10;        if not results.multi_face_landmarks:&#10;            return None&#10;&#10;        landmarks = results.multi_face_landmarks[0]&#10;        coords = np.array(&#10;            [(lm.x, lm.y, lm.z) for lm in landmarks.landmark],&#10;            dtype=np.float32,&#10;        )&#10;        eye_indices = {&#10;            &quot;left&quot;: [33, 160, 158, 133, 153, 144],&#10;            &quot;right&quot;: [263, 387, 385, 362, 380, 373],&#10;        }&#10;&#10;        def calc_ratio(indices: Iterable[int]) -&gt; Tuple[float, float]:&#10;            pts = coords[indices][:, :2]&#10;            vertical = np.linalg.norm(pts[1] - pts[5]) + np.linalg.norm(pts[2] - pts[4])&#10;            horizontal = np.linalg.norm(pts[0] - pts[3])&#10;            ratio = vertical / (2.0 * horizontal + 1e-6)&#10;            return vertical, ratio&#10;&#10;        lid_distances, ratios = [], []&#10;        for eye in eye_indices.values():&#10;            vertical, ratio = calc_ratio(eye)&#10;            lid_distances.append(vertical)&#10;            ratios.append(ratio)&#10;&#10;        eyelid_distance = float(np.mean(lid_distances))&#10;        ear = float(np.mean(ratios))&#10;        is_closed = ear &lt; self.eyelid_threshold&#10;        eye_measurement = EyeMeasurement(&#10;            eyelid_distance=eyelid_distance,&#10;            eye_aspect_ratio=ear,&#10;            is_closed=is_closed,&#10;        )&#10;&#10;        forehead = coords[10]&#10;        chin = coords[152]&#10;        pitch_value = _angle_between(chin - coords[1], np.array([0.0, 1.0, 0.0]))&#10;&#10;        landmarks_px = None&#10;        if include_landmarks:&#10;            h, w = frame.shape[:2]&#10;            landmarks_px = np.column_stack((coords[:, 0] * w, coords[:, 1] * h))&#10;&#10;        return FaceMeasurement(eye=eye_measurement, pitch_deg=pitch_value, landmarks_px=landmarks_px)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>